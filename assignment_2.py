# -*- coding: utf-8 -*-
"""Assignment 2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sjFVDXukke632KURP3ED2IGr2hdIQOo5
"""

import tensorflow as tf
from tensorflow.keras.applications.inception_v3 import InceptionV3, preprocess_input

# Load the pre-trained Inception V3 model
model = InceptionV3(weights='imagenet')

# Preprocess the model
graph = tf.compat.v1.get_default_graph()

!pip install opencv-python

import cv2
import numpy as np
from tensorflow.keras.applications.inception_v3 import InceptionV3
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.inception_v3 import preprocess_input, decode_predictions



# Open the video file
cap = cv2.VideoCapture('video.mp4')

# Initialize the frame counter
frame_count = 0

# Loop through the frames of the video
while True:
    # Read the next frame from the video
    ret, frame = cap.read()

    # If the frame is empty, break the loop
    if not ret:
        break

    # Resize the frame to the required input size of the model
    img = cv2.resize(frame, (299, 299))

    # Preprocess the image for the model
    x = image.img_to_array(img)
    x = np.expand_dims(x, axis=0)
    x = preprocess_input(x)

    # Make a prediction with the model
    preds = model.predict(x)

    # Decode the prediction and print the top 3 predicted objects
    decoded_preds = decode_predictions(preds, top=3)[0]
    print("Top 3 predictions for frame", frame_count)
    for pred in decoded_preds:
        print(pred[1], pred[2])

    # Increment the frame counter
    frame_count += 1

# Release the video file and exit
cap.release()
cv2.destroyAllWindows()

from flask import Flask, render_template, request, redirect, url_for
import os

from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.inception_v3 import preprocess_input, decode_predictions

app = Flask(__name__)

@app.route('/')
def index():
    return render_template('/content/drive/MyDrive/Colab Notebooks/index.html')

@app.route('/', methods=['POST'])
def upload_video():
    # Get the file from the request
    video_file = request.files['video_file']
    
    # Save the file to disk
    video_path = os.path.join(app.config['UPLOAD_FOLDER'], video_file.filename)
    video_file.save(video_path)

    # Split the video into frames
    frames = split_video(video_path)

    # Feed the frames into the Inception V3 model
    results = detect_objects(frames)

    # Display the results
    return render_template('/content/drive/MyDrive/Colab Notebooks/Results.html', results=results)

def split_video(video_path):
    # Open the video file
    cap = cv2.VideoCapture(video_path)

    # Get the frame rate and number of frames
    fps = cap.get(cv2.CAP_PROP_FPS)
    num_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))

    # Initialize an empty list to store the frames
    frames = []

    # Loop through each frame in the video
    for i in range(num_frames):
        # Read the frame
        ret, frame = cap.read()

        # Check if the frame was successfully read
        if ret:
            # Resize the frame to 224x224
            resized_frame = cv2.resize(frame, (224, 224))

            # Preprocess the frame for input to the Inception V3 model
            preprocessed_frame = preprocess_input(resized_frame)

            # Add the preprocessed frame to the list of frames
            frames.append(preprocessed_frame)
        else:
            break

    # Release the video file
    cap.release()

    # Convert the list of frames to a NumPy array
    frames = np.array(frames)

    return frames

def detect_objects(frames):
    # Load the pre-trained Inception V3 model
    model = tf.keras.applications.InceptionV3(weights='imagenet')

    # Make predictions on the frames
    predictions = model.predict(frames)

    # Decode the predictions
    decoded_predictions = decode_predictions(predictions, top=3)

    # Return the results
    return decoded_predictions

if __name__ == '__main__':
    app.config['UPLOAD_FOLDER'] = 'uploads'
    app.run(debug=True)